---
title: COMP 352
layout: course
comments: true
---

2017 Winter

<!--more-->

## Outline

### Instructor
* Instructor: Dr. Dhrubajyoti Goswami
* Office: EV 003.145
* Email: goswami@cs.concordia.ca

### Textbook
Michael T. Goodrich, Roberto Tamassia, and Michael H. Goldwasser. Data Structures and Algorithms in Java (Sixth Edition). John Wiley and Sons (2014).

---

## Ch04: Analysis

### Running Time

### Experimental Studies

* Limitations of Experiments

### Theoretical Analysis

* Pseudocode
* Seven Important Functions
* Primitive Operations
* Counting Primitive Operations

### Big-Oh Notation

![Sort Comparison]({{ site.url }}/assets/COMP 352/bigO.png "Sort Comparison")
[Big-O Cheat Sheet](http://bigocheatsheet.com/)

<svg id="chart" width="800" height="500" xmlns="http://www.w3.org/2000/svg">
    <!-- horrible region -->
    <path d="M50 450 L 50 0 L 800 0 L 800 450 Z" fill="#ff8989"></path>
    <!-- bad region -->
    <path d="M50 450 L 800 0 L 800 450 Z" fill="#FFC543"></path>
    <!-- fair region -->
    <path d="M50 450 L 800 450 L 800 330 Z" fill="yellow"></path>
    <!-- good region -->
    <path d="M50 450 L 800 450 L 800 410 Z" fill="#C8EA00"></path>
    <!-- excellent region -->
    <path d="M50 450 L 800 450 L 800 440 Z" fill="#53d000"></path>

    <!-- axes -->
    <path d="M50 0 L 50 450 L 800 450" fill="transparent" stroke="black" stroke-width="2"></path>

    <path d="M50 448 L 800 448" fill="transparent" stroke="black" stroke-width="2"></path>
    <text x="700" y="438" fill="black">O(log n), O(1)</text>

    <path d="M50 450 L 800 400" fill="transparent" stroke="black" stroke-width="2"></path>
    <text x="760" y="390" fill="black">O(n)</text>

    <path d="M50 450 Q 400 350, 800 150" fill="transparent" stroke="black" stroke-width="2"></path>
    <text x="630" y="190" fill="black">O(n log n)</text>

    <path d="M50 450 Q 180 380, 250 0" fill="transparent" stroke="black" stroke-width="2"></path>
    <text x="260" y="30" fill="black">O(n^2)</text>

    <path d="M50 450 C 100 430, 120 350, 120 0" fill="transparent" stroke="black" stroke-width="2"></path>
    <text x="125" y="20" fill="black">O(2^n)</text>

    <path d="M50 450 C 80 450, 80 350, 80 0" fill="transparent" stroke="black" stroke-width="2"></path>
    <text x="80" y="20" fill="black">O(n!)</text>

    <text x="0" y="0" transform="translate(30 230) rotate(-90)" style="dominant-baseline: middle; text-anchor: middle; font-size:20px; color: #555; font-size:20px; color: #555; font-style: italic;" fill="black">Operations</text>
    <text x="0" y="0" transform="translate(420 470)" style="dominant-baseline: middle; text-anchor: middle; font-size:20px; color: #555; font-style: italic;" fill="black">Elements</text>
</svg>

---

## Ch05: Recursion

### The Recursion Pattern

### Linear Recursion

### Tail Recursion

### Fibonacci

---

## Ch06: Stacks

### Array-based Stack

---

## Ch06: Queues

### Array-based Queue

---

## Ch07: Lists

### Incremental Strategy

### Doubling Strategy

### LinkedLists and Iterators

### ArrayLists and Sequences

---

## Ch08: Trees

### Tree Traversal

* Preorder Traversal
* Postorder Traversal
* Inorder Traversal
* Euler Tour Traversal

### Binary Trees
* Linked Structure
* Array-Based

---

## Ch09: Priority Queues

### Sequence-based Priority Queue

### Unsorted List Implementation

### Sorted List Implementation

### Selection-Sort

### Insertion-Sort

### In-place Insertion-Sort

---

## Ch09: Heap
A heap is a binary tree storing keys at its nodes and satisfying the following properties:

1. Heap-Order: for every internal node v other than the root, *key(v) â‰¥ key(parent(v))*

2. Complete Binary Tree: let *h* be the height of the heap
    * for *i = 0, ... , h - 1*, there are 2^i nodes of depth *i*
    * at depth *h - 1*, the internal nodes are to the left of the external nodes

3. The last node of a heap is the rightmost node of maximum depth

---

## Ch10: HashTables

### Hash Functions and Hash Tables

### Hash Codes

### Collision Handling

### Double Hashing

---

## Ch10: Maps

### Ordered Maps and Dictionaries


---

## Ch11: 24 Trees

---

## Ch11: Binary Search Trees


---

## Ch11: AVL Trees

---

## Ch12: Divide And Conquer


---

## Ch12: Merge Sort

![merge sort]({{ site.url }}/assets/COMP 352/mergesort.gif "merge sort")

---

## Ch12: Quick Sort

![quick sort]({{ site.url }}/assets/COMP 352/quicksort.gif "quick sort")


---

## Ch12: Sorting Lower Bound

---

## Ch12: Bucket Sort and Radix Sort


---

## Ch14: Graph

---

## Ch14: DFS


---

## Ch14: BFS


---

## Ch14: Digraphs


---

## Ch14: Shortest Path

