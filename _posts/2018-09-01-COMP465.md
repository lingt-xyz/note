---
title: COMP 465
layout: course
comments: true
---

2018 Fall

<!--more-->

## Outline

### Instructor
* Instructor: Hovhannes Harutyunyan
* Office: EV 003.155
* Email: haruty@cs.concordia.ca
* Office hours: Thursday 11:40 - 12:40 or by appointment

### Textbook
Introduction to Algorithms, third edition, by T. Cormen, C. Leiserson, R. Rivest, C. Stein, MIT Press, 2009.

### Grading
* 10% Assignments 
* 30% Midterm Exam â€“ in class (week 7 or 8)
* 60% Final Exam

### Assignments
* Assignment 1. (due on September 22, 2018, 11:59pm)
* Assignment 2. (due on October 9, 2018, 11:59pm)
* Assignment 3. (due on November 11, 2018, 11:59pm)
* Assignment 4. (due on November 28, 2018, 11:59pm) 

---

## 4 Divide-and-Conquer

### 4.2 Strassen's algorithm for matrix multiplication

If {% raw %}$$A=(a_{ij}), B=(b_{ij})$${% endraw %} are square {% raw %}$$n\times n$${% endraw %} matrices, then
{% raw %}
$$
C=A\times B, \text{ entry }c_{ij}=\sum_{k=1}^n a_{ik}\cdot b_{kj}
$$
{% endraw %}

* Square-Matrix_Multiply: {% raw %}$$\Theta (n^3)$${% endraw %}

* A simple divide-and-conquer algorithm

    Partition each of *A*, *B*, and *C* into four {% raw %}$$n/2 \times n/2$${% endraw %} matrices

    {% raw %}$$

    \begin{pmatrix}
        A_{11} & A_{12} \\
        A_{21} & A_{22} \\ 
    \end{pmatrix}
    ,
    \begin{pmatrix}
        B_{11} & B_{12} \\
        B_{21} & B_{22} \\ 
    \end{pmatrix}
    ,
    \begin{pmatrix}
        C_{11} & C_{12} \\
        C_{21} & C_{22} \\ 
    \end{pmatrix}

    $${% endraw %}

    so that we rewrite the equation {% raw %}$$C=A\cdot B$${% endraw %} as

    {% raw %}$$
    \begin{pmatrix}
    C_{11} & C_{12} \\
    C_{21} & C_{22} \\ 
    \end{pmatrix}
    =
    \begin{pmatrix}
        A_{11} & A_{12} \\
        A_{21} & A_{22} \\ 
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        B_{11} & B_{12} \\
        B_{21} & B_{22} \\ 
    \end{pmatrix}

    $${% endraw %}

### 4.3 The substitution method for solving recurrences

### 4.4 The recursion0tree method for solving recurrences

---

## 7 Quicksort

### 7.1 Description of quicksort

### 7.2 Performance of quicksort

### 7.3 A randomized version of quicksort

### 7.4 Analysis of quicksort

---

## 9 Medians and Order Statistics

### 9.1 Minimum and maximum

### 9.2 Selection in expected linear time

### 9.3 Selection in worst-case linear time

---

## 15 Dynamic Programming

### 15.1 Rod cutting

### 15.2 Matrix-chain multiplication

### 15.3 Elements of dynamic programming

### 15.4 Longest common subsequence

### 15.5 Optimal binary search trees

---

## 16 Greedy Algorithms

### 16.1 Anactivity-selection problem

### 16.2 Elements of greedy strategy

### 16.3 Huffman codes

---

## 17 Amortized Analysis

### 17.1 Aggregate analysis

### 17.2 The accounting method

### 17.3 The potential method

---

## 22 Elementary Graph Algorithms

### 22.1 Representations of graphs
### 22.2 Breadth-first search
### 22.3 Depth-first search
### 22.4 Topological sort
### 22.5 Strongly connected components

---

## 23 Minimum Spanning Trees
### 23.1 Growing a minimum spanning tree
### 23.2 The algorithms of Kruskal and Prim

---

## 24 Single-Source Shortest Paths

### 24.1 The Bellman-Ford algorithm
### 24.2 Single-source shortest paths in directed acyclic graphs
### 24.3 Dijkstra's algorithm
### 24.4 Difference constraints and shortest paths
### 24.5 Proofs of shortest-paths properties

---

## 25 All-Pairs Shortest Paths

### 25.2 The Floyed-Warshall algorithm

---

## 26 Maximum Flow

### 26.1 Flow networks
### 26.2 The Ford-Fulkerson method
### 26.3 Maximum bipartite matching

---

## 29 Linear Programming

### 29.1 Standard and slack forms
### 29.2 Formulating problems as linear programs
### 29.3 The simplex algorithm
### 29.4 Duality
### 29.5 The initial basic feasible solution

---

## 32 String Matching

### 32.1 The naive string-matching algorithm
### 32.2 The Rabin-Karp algorithm

---

## 34 NP-Completeness

### 34.1 Polynomial time
### 34.2 Polynoimal-time verification
### 34.3 NP-completeness and reducibility
### 34.5 NP-complete problems
---

## 35 Approximation Algorithms

### 35.1 The vertex-cover problem
### 35.2 The travling-salesman problem
### 35.3 The set-covering problem
### 35.5 The subset-sum problem